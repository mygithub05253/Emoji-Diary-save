<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Emoji Diary Auth Test</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      .section {
        border: 1px solid #ccc;
        padding: 20px;
        margin-bottom: 20px;
        border-radius: 5px;
      }
      h2 {
        margin-top: 0;
      }
      input,
      select,
      button {
        margin: 5px 0;
        padding: 8px;
        width: 100%;
        box-sizing: border-box;
      }
      button {
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
      }
      button:hover {
        background-color: #0056b3;
      }
      #result {
        background-color: #f0f0f0;
        padding: 10px;
        white-space: pre-wrap;
      }
      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <h1>Emoji Diary API Test</h1>

    <!-- Status -->
    <div id="authStatus" class="section">
      상태: <span id="statusText">로그아웃됨</span>
      <button id="logoutBtn" class="hidden" onclick="logout()">로그아웃</button>
    </div>

    <!-- Sign Up -->
    <div id="signupSection" class="section">
      <h2>회원가입</h2>
      <input type="text" id="signupName" placeholder="이름 (2자 이상)" />
      <input type="email" id="signupEmail" placeholder="이메일" />
      <button onclick="checkEmail()">이메일 중복 확인</button>
      <button onclick="sendVerificationCode()">인증 코드 발송</button>
      <input type="text" id="verificationCode" placeholder="인증 코드" />
      <button onclick="verifyCode()">인증 코드 확인</button>
      <input
        type="password"
        id="signupPassword"
        placeholder="비밀번호 (8자 이상, 영문/숫자/특수문자)"
      />
      <button onclick="register()">가입하기</button>
    </div>

    <!-- Password Reset -->
    <div class="section">
      <h2>비밀번호 찾기</h2>
      <input type="email" id="resetEmail" placeholder="가입한 이메일" />
      <button onclick="sendResetCode()">인증 코드 발송</button>

      <input type="text" id="resetCode" placeholder="인증 코드 6자리" />
      <button onclick="verifyResetCode()">인증 코드 확인</button>

      <input type="password" id="newPassword" placeholder="새 비밀번호" />
      <input
        type="password"
        id="confirmPassword"
        placeholder="새 비밀번호 확인"
      />
      <button onclick="resetPassword()">비밀번호 재설정</button>
    </div>

    <!-- Login -->
    <div id="loginSection" class="section">
      <h2>로그인</h2>
      <input type="email" id="loginEmail" placeholder="이메일" />
      <input type="password" id="loginPassword" placeholder="비밀번호" />
      <button onclick="login()">로그인</button>
    </div>

    <!-- Persona Setup -->
    <div id="personaSection" class="section hidden">
      <h2>페르소나 설정</h2>
      <p>현재 페르소나: <span id="currentPersona">Loading...</span></p>
      <select id="updatePersonaSelect">
        <option value="BEST_FRIEND">Best Friend (친한 친구)</option>
        <option value="PARENTS">Parents (부모님)</option>
        <option value="EXPERT">Expert (전문가)</option>
        <option value="MENTOR">Mentor (멘토)</option>
        <option value="COUNSELOR">Counselor (상담사)</option>
        <option value="POET">Poet (시인)</option>
      </select>
      <button onclick="updatePersona()">변경하기</button>
    </div>

    <!-- Profile -->
    <div id="profileSection" class="section hidden">
      <h2>내 정보</h2>
      <button onclick="getProfile()">정보 조회</button>
      <div id="profileData"></div>
    </div>

    <!-- Diary Create -->
    <div id="diarySection" class="section">
      <h2>일기 작성 (이미지 업로드 테스트)</h2>
      <input type="date" id="diaryDate" value="2023-12-08" />
      <input type="text" id="diaryTitle" placeholder="제목" />
      <textarea
        id="diaryContent"
        placeholder="내용"
        style="width: 100%; height: 100px; margin: 5px 0"
      ></textarea>
      <!-- Mood Select (Using Korean Enum values) -->
      <select id="diaryMood">
        <option value="행복">행복</option>
        <option value="슬픔">슬픔</option>
        <option value="분노">분노</option>
        <option value="불안">불안</option>
        <option value="중립">중립</option>
      </select>
      <input type="text" id="diaryWeather" placeholder="날씨 (예: 맑음)" />

      <!-- Image Upload Input -->
      <div style="margin: 10px 0; border: 1px dashed #ccc; padding: 10px">
        <label>이미지 첨부: </label>
        <input type="file" id="diaryImage" accept="image/*" multiple />
      </div>

      <button onclick="createDiary()">일기 작성 (+이미지)</button>
    </div>

    <!-- Result Log -->
    <div class="section">
      <h2>결과 로그</h2>
      <div id="result"></div>
    </div>

    <script>
      let accessToken = localStorage.getItem("accessToken");
      let refreshToken = localStorage.getItem("refreshToken");

      function updateAuthStatus() {
        if (accessToken) {
          document.getElementById("statusText").innerText = "로그인됨";
          document.getElementById("logoutBtn").classList.remove("hidden");
          document.getElementById("signupSection").classList.add("hidden");
          document.getElementById("loginSection").classList.add("hidden");
          document.getElementById("profileSection").classList.remove("hidden");
          document.getElementById("personaSection").classList.remove("hidden");
          fetchUserInfo();
        } else {
          document.getElementById("statusText").innerText = "로그아웃됨";
          document.getElementById("logoutBtn").classList.add("hidden");
          document.getElementById("signupSection").classList.remove("hidden");
          document.getElementById("loginSection").classList.remove("hidden");
          document.getElementById("profileSection").classList.add("hidden");
          document.getElementById("personaSection").classList.add("hidden");
        }
      }

      function log(message, data) {
        const el = document.getElementById("result");
        el.innerText =
          message +
          (data ? "\n" + JSON.stringify(data, null, 2) : "") +
          "\n\n" +
          el.innerText;
      }

      async function api(url, method, body, auth = false) {
        const headers = { "Content-Type": "application/json" };
        if (auth && accessToken) {
          headers["Authorization"] = "Bearer " + accessToken;
        }

        try {
          const response = await fetch(url, {
            method: method,
            headers: headers,
            body: body ? JSON.stringify(body) : null,
          });
          const data = await response.json();
          log(`${method} ${url} 결과:`, data);
          return data;
        } catch (error) {
          log(`${method} ${url} 에러:`, error);
          throw error;
        }
      }

      async function checkEmail() {
        const email = document.getElementById("signupEmail").value;
        const res = await api("/api/auth/check-email", "POST", { email });
        if (res.success) {
          alert(res.data.message);
        } else {
          alert(res.error.message);
        }
      }

      async function sendVerificationCode() {
        const email = document.getElementById("signupEmail").value;
        await api("/api/auth/send-verification-code", "POST", { email });
        alert("인증 코드가 발송되었습니다 (콘솔/로그 확인 필요)");
      }

      async function verifyCode() {
        const email = document.getElementById("signupEmail").value;
        const code = document.getElementById("verificationCode").value;
        const res = await api("/api/auth/verify-code", "POST", { email, code });
        if (res.success) {
          alert(res.data.message);
        } else {
          alert(res.error.message);
        }
      }

      async function register() {
        const req = {
          name: document.getElementById("signupName").value,
          email: document.getElementById("signupEmail").value,
          password: document.getElementById("signupPassword").value,
          emailVerified: true, // 테스트 편의상 true로 보냄 (서버에서 체크함)
        };
        const res = await api("/api/auth/register", "POST", req);
        if (res.success) {
          accessToken = res.data.accessToken;
          refreshToken = res.data.refreshToken;
          localStorage.setItem("accessToken", accessToken);
          localStorage.setItem("refreshToken", refreshToken);
          updateAuthStatus();
          alert("가입 성공! 자동 로그인됩니다.");
        } else {
          alert("회원가입 실패: " + res.error.message);
        }
      }

      async function login() {
        const req = {
          email: document.getElementById("loginEmail").value,
          password: document.getElementById("loginPassword").value,
        };
        const res = await api("/api/auth/login", "POST", req);
        if (res.success) {
          accessToken = res.data.accessToken;
          refreshToken = res.data.refreshToken;
          localStorage.setItem("accessToken", accessToken);
          localStorage.setItem("refreshToken", refreshToken);
          updateAuthStatus();
          alert("로그인 성공!");
        }
      }

      async function fetchUserInfo() {
        const res = await api("/api/users/me", "GET", null, true);
        if (res.success) {
          document.getElementById("currentPersona").innerText =
            res.data.persona;
        }
      }

      async function updatePersona() {
        const persona = document.getElementById("updatePersonaSelect").value;
        const res = await api(
          "/api/users/me/persona",
          "PUT",
          { persona },
          true
        );
        if (res.success) {
          alert(res.data.message);
          fetchUserInfo(); // Refresh info
        } else {
          alert(res.error.message);
        }
      }

      async function getProfile() {
        const res = await api("/api/users/me", "GET", null, true);
        if (res.success) {
          document.getElementById("profileData").innerText = JSON.stringify(
            res.data,
            null,
            2
          );
        }
      }

      async function logout() {
        if (refreshToken) {
          await api("/api/auth/logout", "POST", { refreshToken });
        }
        accessToken = null;
        refreshToken = null;
        localStorage.removeItem("accessToken");
        localStorage.removeItem("refreshToken");
        updateAuthStatus();
        alert("로그아웃 되었습니다.");
      }

      // --- New: Diary Creation with Image ---
      async function uploadImages() {
          const fileInput = document.getElementById("diaryImage");
          const files = fileInput.files;
          if (!files || files.length === 0) return [];

          const formData = new FormData();
          for (let i = 0; i < files.length; i++) {
              formData.append("image", files[i]);
          }

          try {
              const res = await fetch("/api/upload/image", {
                  method: "POST",
                  headers: {
                      "Authorization": "Bearer " + accessToken
                  },
                  body: formData
              });
              const data = await res.json();
              if (data.success) {
                  return data.data.imageUrls; // Changed to match new backend response
              } else {
                  throw new Error("Image Upload Failed");
              }
          } catch (e) {
              log("Image Upload Error", e);
              throw e;
          }
      }

      async function checkDiaryDate(date) {
          try {
              // GET /api/diaries/date/{date} -> 200 if exists, 400/404 if not (handled by GlobalExceptionHandler)
              // Note: Our current getDiaryByDate service throws IllegalArgumentException if not found -> 400 Bad Request
              const res = await api("/api/diaries/date/" + date, "GET", null, true);
              if (res.id || res.date) { // Successfully found a diary
                  return true; // Exists
              }
              return false;
          } catch (e) {
              // If API throws 400/404/500, fetch throws? 
              // Wait, 'api' function doesn't throw on non-200, it returns data.
              // BUT 'api' function implementation: "const data = await response.json(); log... return data;"
              // If response is 400, data will be { success: false, error: { ... } } (from GlobalExceptionHandler)
              // So 'api' returns the error object. 
              // If the service throws Exception for "Not Found", it returns { success: false ... }.
              return false; // Does not exist (or error, allow creation to attempt and fail properly)
          }
      }

      async function createDiary() {
          try {
              const date = document.getElementById("diaryDate").value;
              if (!date) {
                  alert("날짜를 선택해주세요.");
                  return;
              }

              // 0. Pre-check for duplicate date
              // We manually check response to see if it's a success (Diary found)
              // api() wrapper returns the parsed JSON. 
              // If success, it returns DiaryResponse (which has id).
              // If error (not found), it returns { success: false, ... }
              const checkRes = await api("/api/diaries/date/" + date, "GET", null, true);
              
              // If checkRes has 'id' or 'date', it means a diary exists.
              // Note: existing implementation returns DiaryResponse directly on success?
              // DiaryController: return ResponseEntity.ok(diaryService.getDiaryByDate(...)); 
              // DiaryResponse doesn't have "success" field wrapping it unless we changed ResponseAdvice.
              // Looking at DiaryController, it returns DiaryResponse object directly!
              // BUT GlobalExceptionHandler returns map with success:false on error.
              
              if (checkRes && checkRes.id) {
                  alert("이미 해당 날짜에 작성된 일기가 있습니다. 일기를 수정해주세요.");
                  return; // *** PREVENT IMAGE UPLOAD ***
              }

              let imageUrls = [];
              // 1. Upload Images if selected
              if (document.getElementById("diaryImage").files.length > 0) {
                  try {
                      imageUrls = await uploadImages();
                      log("이미지 업로드 성공: " + JSON.stringify(imageUrls));
                  } catch (uploadError) {
                      alert("이미지 업로드 중 오류가 발생했습니다: " + uploadError.message);
                      return;
                  }
              }

              // 2. Create Diary
              const req = {
                  date: date,
                  title: document.getElementById("diaryTitle").value,
                  content: document.getElementById("diaryContent").value,
                  mood: document.getElementById("diaryMood").value,
                  weather: document.getElementById("diaryWeather").value || "맑음",
                  images: imageUrls
              };

              // Note: The controller returns DiaryResponse directly on success (no 'success' field wrapper likely, based on Controller code)
              // Wait, previous `api` usages assumed `res.success`. 
              // Let's check `api` function again in line 191.
              // It returns `data`. 
              // Check DiaryController `createDiary`: return ResponseEntity.ok(diaryService.createDiary(...));
              // It returns pure JSON of DiaryResponse.
              // BUT `GlobalExceptionHandler` returns { success: false, error: ... }.
              // SO: Success = object with ID. Failure = object with success:false.
              // This inconsistency in API response wrapper is a potential issue but let's handle it.
              
              const res = await api("/api/diaries", "POST", req, true);
              
              if (res && res.id) { // Success (DiaryResponse has ID)
                   alert("일기 작성 성공! (음식 추천: " + (res.recommendedFood?.name || "없음") + ")");
              } else if (res && res.success === false) { // Handled Error
                   const msg = res.error ? res.error.message : "알 수 없는 오류";
                   alert("일기 작성 실패: " + msg);
              } else {
                   // Fallback
                   alert("일기 작성 실패 (응답 확인 필요)");
              }

          } catch (e) {
              alert("작성 중 오류 발생: " + (e.message || e));
          }
      }
      // --------------------------------------

      let currentResetToken = null;

      async function sendResetCode() {
        const email = document.getElementById("resetEmail").value;
        const res = await api("/api/auth/password-reset/send-code", "POST", {
          email,
        });
        if (res.success) alert(res.data.message);
        else alert(res.error.message);
      }

      async function verifyResetCode() {
        const email = document.getElementById("resetEmail").value;
        const code = document.getElementById("resetCode").value;
        const res = await api("/api/auth/password-reset/verify-code", "POST", {
          email,
          code,
        });
        if (res.success) {
          currentResetToken = res.data.resetToken; // Store the token
          alert("인증되었습니다. 새 비밀번호를 설정해주세요.");
        } else {
          alert(res.error.message);
        }
      }

      async function resetPassword() {
        const email = document.getElementById("resetEmail").value;
        const newPassword = document.getElementById("newPassword").value;
        const confirmPassword =
          document.getElementById("confirmPassword").value;

        if (!currentResetToken) {
          alert("먼저 이메일 인증을 완료해주세요.");
          return;
        }

        const res = await api("/api/auth/password-reset/reset", "POST", {
          email,
          newPassword,
          confirmPassword,
          resetToken: currentResetToken,
        });

        if (res.success) {
          alert(res.data.message);
        } else {
          alert(res.error.message);
        }
      }

      // Initial check
      updateAuthStatus();
    </script>
  </body>
</html>
